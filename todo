# Testing

- just do mapper_000 since it will work for the test rom and donkey kong

## odin stuff

default_allocator :: heap_allocator
default_allocator_proc :: heap_allocator_proc

heap allocator has no data of what is storing so u can't know what was allocated, and how many bytes were allocated


	Default_Temp_Allocator :: struct {
		arena: Arena,
	}

temp allocator is an arena
core/mem/allocators.odin


- figure out how to figure out how much allocators are allocating
- does the temp allocator even exist if u don't init it?


## Todo

- you are writing to the cpu stack. prob in the ppu registers. fix that.




- run some nes test roms to see what is going on.
 donkey kong is getting stuck somewhere. never writes to PPUADDR

- don't allocate memory for the whole bus.
 the bus is a fake thing. it's not ram
 put actual ram in separate fields. it's easier.


- it doesn't write to PPUCTRL. donkey kong. it never does. figure out why

# PPU

- do a test run of donkey kong to see how it uses the registers.
- implement enough PPU stuff so that donkey kong can draw its own backgrounds.

status register:

See: PPU rendering for more information on the timing of setting and clearing the flags.


- how do i set all the flags? or like how do i make sure that the flags are set correctly when read?


- what is nmi?


- what calls the nmi?

- the ppu calls the nmi when:
	- you write to ppuctrl on some conditions (if vblank is set, and you change nmi flag from 0 to 1, trigger nmi now)
	- when vblank starts and bit 7 of ppuctrl is on




## Input

write 1 -> $4016: signal controller to poll its input
write 0 -> $4016: signal controller to finish its poll

read $4016 or $4017: reads controller input (port 0 or 1), one bit at a time
	reads highest bit only. then it left shifts by one bit
	reads right shifts bits by one

order of inputs:

(highest bit) -> lowest bit

A B Select Start Up Down Left Right
