# faulty ops

F0 E6 C8 48 B4 B1 AA 2A 20 9D 78 D0 C6 B9 A8 A5 91 8A A F6 D8 30 B0 AD 26 99 88 6A 60 D6 56 38 B5 9A 10 90 8D 6 E8 68 CA 4A 40 BD 29 98 18 15 95

found something:

ppu was running like crazy sometimes.
many more times than it should, in one instruction

turns out it was because OAMDMA. it happens when you write to OAMDMA.

take care of that, u probably do it really badly.

<!-- //OAMDMA
	case 0x4014:
		// fmt.printfln("writing to OAMDMA")

		start_addr: u16 = u16(val) << 8

		for i in 0x0000 ..= 0x00FF {
			v := read(nes, u16(i) + start_addr)
			ppu_oam[i] = v
		}

		return
	} -->

- you have to understand cycles better. read the document

	https://www.nesdev.org/6502_cpu.txt


# debugging bomberman

i'm investigating NMI.

NMI subroutine is at $C01A

things I found so far:


- Note 1:


in my emu, bomberman goes to NMI from either $C293 or $C290.

in mesen, it's going from:

$CBFD, or
$CBFB

- Note 2:

In mesen, when NMI subroutine is running, the ppu cycle is at between 25-33

in my emu, when NMI subroutine starts, ppu cycle is at between 2-13


- Proposed solution:

when wanting to trigger an NMI, instead of just doing the thing right there (calling nmi()), just set a flag.
when you run the next instruction, check for the flag, and call nmi() accordingly.

update: i already did it. same results.


update:

If you run NMI after running the instruction normally, then bomberman start screen works. it's weird.

The entities don't move in gameplay. Work still needs to be done

update 2:

I noticed this in the "tricky to emulate games" article:

Adventures of Lolo 2, Ms. Pac-Man (Tengen), and Spelunker
    These rely on 1-cycle NMI delay when PPUSTATUS ($2002) bit 7 gets set inside vblank (if $2002 has not been read yet), in which PPUSTATUS bit 7 can be read as true.


I tested Spelunker. I support its mapper. I get a black screen after the intro.

If I fix Spelunker, I might fix Bomberman. Perhaps

update 3:

it's due to my emulator not being per-cycle accurate. i need that now.

This is why you need per-cycle accuracy:

i believe so. let me describe the case so we make sure i understand:

- in bomberman, in my current emulation, before doing the NMI delay:

CPU instruction run: runs $C290 (LDA PPUSTATUS). reads 0 from status
PPU tick run: Vblank is reached. NMI is triggered.
CPU instruction run: jumps to NMI. NMI proc clears vblank. back to 0. returns.
CPU instruction run: runs $C293 (BPL $C290). it jumps to c290 because the negative flag is 0

repeat

- now in-cycle accurate emulation:

CPU instruction run: runs $C290 (LDA PPUSTATUS). PPU tick is ran while this CPU instruction is being ran, and VBLANK is reached, and NMI is triggered. If this is done before the read to PPUSTATUS, then the instruction will still catch the vblank and store it in the CPU flags and accumulator.

when jumping to NMI, the flags with bit 7 set will be stored in the stack. so when returning back to C293, BPL won't jump back, and the code won't be stuck

so this only happens when NMI is triggered on the real NES when LDA is being executed, and the NMI proc reads PPU status.

# todo

- Look into turning your emulator more accurate by interleaving PPU calls in your cpu instructions and such.
	https://www.nesdev.org/wiki/Catch-up

	do this:

	https://forums.nesdev.org/viewtopic.php?t=24939

- an article on 6502 interrupts
	http://wilsonminesco.com/6502interrupts/

- make bomberman run. it might be a NMI thing.
	https://forums.nesdev.org/viewtopic.php?t=12222&sid=5198a50987eb742fe2fd2361ed224335&start=15

- Wrap up audio
	- Make Mario sound normal
	- DMC channel

- save states

# Input

write 1 -> $4016: signal controller to poll its input
write 0 -> $4016: signal controller to finish its poll

read $4016 or $4017: reads controller input (port 0 or 1), one bit at a time
	reads highest bit only. then it left shifts by one bit
	reads right shifts bits by one

order of inputs:

(highest bit) -> lowest bit

A B Select Start Up Down Left Right

# possible bug

when i was playing mario and i went rainbow mode, this happened:

edit: it happens at other times too.

idk what u read/writing here at ppu bus FFF6
idk what u read/writing here at ppu bus FFFE
idk what u read/writing here at ppu bus FFF6
idk what u read/writing here at ppu bus FFFE
idk what u read/writing here at ppu bus FFF3
idk what u read/writing here at ppu bus FFFB
idk what u read/writing here at ppu bus FFF3
idk what u read/writing here at ppu bus FFFB
idk what u read/writing here at ppu bus FFF0
idk what u read/writing here at ppu bus FFF8
idk what u read/writing here at ppu bus FFF0
idk what u read/writing here at ppu bus FFF8
idk what u read/writing here at ppu bus FFF5
idk what u read/writing here at ppu bus FFFD
idk what u read/writing here at ppu bus FFF5
idk what u read/writing here at ppu bus FFFD
idk what u read/writing here at ppu bus FFF2
idk what u read/writing here at ppu bus FFFA
idk what u read/writing here at ppu bus FFF2
idk what u read/writing here at ppu bus FFFA

# notes compared to javidx

it seems he has the same sprite misalignment as me.
sprites are one pixel to the left. or more.
also they are one pixel up. i checked

see this for reference
https://www.youtube.com/watch?v=7qirrV8w5SQ&t=344s


# Todo

- the hack u did to place sprites better causes problems.
u are adding to x to a u8 so it will wrap. so sprites show up on the left when they're off screen

- don't allocate memory for the whole bus.
 the bus is a fake thing. it's not ram
 put actual ram in separate fields. it's easier.

# odin stuff

default_allocator :: heap_allocator
default_allocator_proc :: heap_allocator_proc

heap allocator has no data of what is storing so u can't know what was allocated, and how many bytes were allocated


	Default_Temp_Allocator :: struct {
		arena: Arena,
	}

temp allocator is an arena
core/mem/allocators.odin


- figure out how to figure out how much allocators are allocating
- does the temp allocator even exist if u don't init it?



# Playable games list:

SMB1
Megaman 1
Contra
Duck Tales
Castlevania
Metal Gear
Ice Climber
Donkey Kong
Kung Fu
